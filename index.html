<html>
<head>
<title>CS-416 Data Visualization</title>
</head>

<script src="https://d3js.org/d3.v6.js"></script>

<body onload='init()'>

<div id="scene1"></div>

<script>

async function init() {

data = await d3.csv("https://covidtracking.com/data/download/all-states-history.csv");

states = d3.groups(data, d => d.state);

states_death = d3.rollup(data, d => d3.sum(d, s => parseInt(s.death)), d => d.state);
states_hospitalized = d3.rollup(data, d => d3.sum(d, s => parseInt(s.hospitalizedCurrently)), d => d.state);

const data_combined = new Map();
states_hospitalized.forEach((obj, k) => data_combined.set(k,  {"death": states_death.get(k), "hospitalized":obj }  ));

states_death_arr = d3.rollups(data, d => d3.sum(d, s => parseInt(s.death)), d => d.state);
states_hospitalized_arr = d3.rollups(data, d => d3.sum(d, s => parseInt(s.hospitalizedCurrently)), d => d.state);

let minValueDeath = states_death_arr.reduce((prev, curr) => prev[1] < curr[1] ? prev : curr);
let maxValueDeath = states_death_arr.reduce((prev, curr) => prev[1] > curr[1] ? prev : curr);

let minValueHospitalized = states_hospitalized_arr.reduce((prev, curr) => prev[1] < curr[1] ? prev : curr);
let maxValueHospitalized = states_hospitalized_arr.reduce((prev, curr) => prev[1] > curr[1] ? prev : curr);


// X Axis
x = d3.scaleLinear().domain([minValueDeath[1], maxValueDeath[1]]).range([0, 600]);
// x = d3.scaleLog().domain([minValueDeath[1], maxValueDeath[1]]).range([0, 600]).base(2);

d3.select("#scene1").append("svg").attr("width", 700).attr("height", 700)
    .append("g")
    .attr("transform", "translate(100,650)")
    .call(d3.axisBottom(x));

// Y axis
var y = d3.scaleLinear().domain([minValueHospitalized[1], maxValueHospitalized[1]]).range([600, 0]);
// var y = d3.scaleLog().domain([minValueHospitalized[1], maxValueHospitalized[1]]).range([600, 0]).base(2);

d3.select("#scene1").select("svg").append("g")
    .attr("transform", "translate(100,50)")
    .call(d3.axisLeft(y));

let sequentialScale = d3.scaleSequential()
  .domain([0, 56])
  .interpolator(d3.interpolateRainbow);

var tooltip = d3.select("#scene1")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "1px")
    .style("border-radius", "5px")
    .style("padding", "10px")
    .style("position", "fixed")

const mouseover = function(event, d) {
    tooltip.style("opacity", 1)
}

const mousemove = function(event, d) {
    tooltip
      .html("<strong>State:</strong> " + d[0] + 
            "<br><strong>Death</strong>: " + d3.format(",.2r")(d[1].death) + 
            "<br><strong>Hospitalized</strong>: " + d3.format(",.2r")(d[1].hospitalized))
      .style("left", d3.select(this).attr("cx") + "px") 
      .style("top", d3.select(this).attr("cy")  + "px")
}

const mouseleave = function(event, d) {
    tooltip
      .transition()
      .duration(200)
      .style("opacity", 0)
}

d3.select("#scene1").select("svg").append('g')
    .attr("transform", "translate(100,100)")
    .selectAll()
    .data(data_combined)
    .enter()
    .append("circle")
      .attr("cx", function (d, i) { return x(d[1].death); } )
      .attr("cy", function (d, i) { return y(d[1].hospitalized)-50; } )
      .attr("r", 4)
      .style("fill", function(d,i) {return sequentialScale(i);})
      .on("mouseover", mouseover )
    .on("mousemove", mousemove )
    .on("mouseleave", mouseleave )


}
 
</script>

</body>
</html>